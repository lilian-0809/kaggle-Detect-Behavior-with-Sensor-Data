# AUTOGENERATED! DO NOT EDIT! File to edit: ../../src/script.ipynb.

# %% auto 0
__all__ = ['Metric']

# %% ../../src/script.ipynb
import torch
import numpy as np
import pandas as pd
from sklearn.metrics import f1_score

# %% ../../src/script.ipynb
class Metric:
    def __init__(self):
        self.target_gestures = [
            'Above ear - pull hair',
            'Cheek - pinch skin',
            'Eyebrow - pull hair',
            'Eyelash - pull hair',
            'Forehead - pull hairline',
            'Forehead - scratch',
            'Neck - pinch skin',
            'Neck - scratch',
        ]
        self.non_target_gestures = [
            'Write name on leg',
            'Wave hello',
            'Glasses on/off',
            'Text on phone',
            'Write name in air',
            'Feel around in tray and pull out an object',
            'Scratch knee/leg skin',
            'Pull air toward your face',
            'Drink from bottle/cup',
            'Pinch knee/leg skin'
        ]
        self.all_classes = self.target_gestures + self.non_target_gestures
        self.gts = dict()
        self.preds = dict()
        self.gts_p = dict()
        self.preds_p = dict()
        self.auto_idx = 0
        self.auto_idx_p = 0

    def add(self, gts, preds, ids=None):
        if ids is None:
            ids = range(self.auto_idx, self.auto_idx + len(gts))
            self.auto_idx += len(gts)
        for gt, pred, id_ in zip(gts, preds, ids):
            if torch.is_tensor(id_):
                id_ = id_.item()
            self.gts[id_] = gt
            self.preds[id_] = pred

    def add_p(self, gts_p, preds_p, ids=None):
        if ids is None:
            ids = range(self.auto_idx_p, self.auto_idx_p + len(gts_p))
            self.auto_idx_p += len(gts_p)
        for gt_p, pred_p, id_ in zip(gts_p, preds_p, ids):
            if torch.is_tensor(id_):
                id_ = id_.item()
            self.gts_p[id_] = gt_p
            self.preds_p[id_] = pred_p

    def merge_p(self, *metrics):
        for metric in metrics:
            assert set(self.gts_p.keys()) == set(metric.gts_p.keys()), "GT not same, plz check"
            for id_ in self.gts_p.keys():
                assert np.allclose(self.gts_p[id_], metric.gts_p[id_]), f"GT values not same for ID {id_}"
                
        all_ids = list(self.preds_p.keys())
        num_classes = len(next(iter(self.preds_p.values())))
        combined = np.zeros((len(metrics)+1, len(all_ids), num_classes))
        for i, id_ in enumerate(all_ids):
            combined[0, i] = self.preds_p[id_]
        for m_idx, metric in enumerate(metrics, 1):
            for i, id_ in enumerate(all_ids):
                combined[m_idx, i] = metric.preds_p[id_]
        avg_preds = combined.mean(axis=0)
        for i, id_ in enumerate(all_ids):
            self.preds_p[id_] = avg_preds[i].tolist()

    def apply_weight(self, weight):
        all_preds = np.array(list(self.preds_p.values()))
        weighted = all_preds * weight
        for id_, pred in zip(self.preds_p.keys(), weighted):
            self.preds_p[id_] = pred.tolist()

    def merge_vote(self, *metrics):
        for metric in metrics:
            assert set(self.gts.keys()) == set(metric.gts.keys()), "GT IDs not same, please check"
            for id_ in self.gts.keys():
                assert self.gts[id_] == metric.gts[id_], f"GT values not same for ID {id_}"
        
        id_to_preds = defaultdict(list)
        for metric in [self] + list(metrics):
            id_to_preds.update(metric.preds)
        vote_results = {}
        for id_, preds in id_to_preds.items():
            from collections import Counter
            counts = Counter(preds)
            max_count = max(counts.values())
            candidates = [k for k, v in counts.items() if v == max_count]
            vote_results[id_] = candidates[0] if len(candidates) == 1 else preds[0]
        self.preds.update(vote_results)
    
    def clear(self):
        self.gts.clear()
        self.preds.clear()
        self.gts_p.clear()
        self.preds_p.clear()
        self.auto_idx = 0
        self.auto_idx_p = 0

    def score(self):
        sorted_ids = sorted(self.gts.keys())
        gts_list = [self.gts[id_] for id_ in sorted_ids]
        preds_list = [self.preds[id_] for id_ in sorted_ids]
        gts_pd = pd.Series(gts_list)
        preds_pd = pd.Series(preds_list)
        y_true_bin = gts_pd.isin(self.target_gestures).values
        y_pred_bin = preds_pd.isin(self.target_gestures).values
        f1_binary = f1_score(y_true_bin, y_pred_bin, pos_label=True, zero_division=0, average='binary')
        y_true_mc = gts_pd.apply(lambda x: x if x in self.target_gestures else 'non_target')
        y_pred_mc = preds_pd.apply(lambda x: x if x in self.target_gestures else 'non_target')
        f1_macro = f1_score(y_true_mc, y_pred_mc, average='macro', zero_division=0)
        return 0.5 * f1_binary + 0.5 * f1_macro

    def acc(self):
        sorted_ids = sorted(self.gts.keys())
        gts = np.array([self.gts[id_] for id_ in sorted_ids])
        preds = np.array([self.preds[id_] for id_ in sorted_ids])
        return np.sum(preds == gts) / len(gts)

    def score_p(self, classes):
        sorted_ids = sorted(self.gts_p.keys())
        gts_list = [classes[np.argmax(self.gts_p[id_])] for id_ in sorted_ids]
        preds_list = [classes[np.argmax(self.preds_p[id_])] for id_ in sorted_ids]
        gts_pd = pd.Series(gts_list)
        preds_pd = pd.Series(preds_list)
        y_true_bin = gts_pd.isin(self.target_gestures).values
        y_pred_bin = preds_pd.isin(self.target_gestures).values
        f1_binary = f1_score(y_true_bin, y_pred_bin, pos_label=True, zero_division=0, average='binary')
        y_true_mc = gts_pd.apply(lambda x: x if x in self.target_gestures else 'non_target').values
        y_pred_mc = preds_pd.apply(lambda x: x if x in self.target_gestures else 'non_target').values
        f1_macro = f1_score(y_true_mc, y_pred_mc, average='macro', zero_division=0)
        return 0.5 * f1_binary + 0.5 * f1_macro

    def acc_p(self):
        sorted_ids = sorted(self.gts.keys())
        gts = np.array([classes[np.argmax(self.gts_p[id_])] for id_ in sorted_ids])
        preds = np.array([classes[np.argmax(self.preds_p[id_])] for id_ in sorted_ids])
        return np.sum(preds == gts) / len(gts)